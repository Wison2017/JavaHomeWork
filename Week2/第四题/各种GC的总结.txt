一、串行GC：
   1、年轻代：标记-复制算法；
   2、老年代：标记-清除-整理算法；
   3、由于是单线程垃圾收集器，GC过程会触发STW；
总结：串行GC无法充分利用多核CPU，比较适合单核CPU的服务器，堆内存几百兆的JVM，如果堆内存过大，那么可能导致JVM出现停顿时间过长的现象；

二、并行GC：
   1、年轻代：标记-复制算法；
   2、老年代：标记-清除-整理算法；
   3、年轻代和老年代的GC都会触发STW，GC过程会使用多个线程执行，从而减少整体的GC时间；
总结：相对比串行GC，并行GC可以降低停顿时间，增加吞吐量；

三、CMS：
   1、年轻代：标记-复制算法；
   2、老年代：标记-清除算法；（没有整理，用空闲列表来管理内存空间的回收，目的是为了降低老年代GC的卡顿时间）
   3、CMS在标记-清除的阶段大部分工作和应用线程一起并发执行，这样也可以降低GC卡顿的时间；
总结：相比并行GC，CMS为了减少GC的卡顿时间，采用了两个方法：老年代不整理；标记-清除的时候，GC线程和业务线程一起工作。但是，由于没有整理（压缩内存），容易出现内存碎片化问题，在某些情况下GC会造成不可预测的暂停时间，特别是在堆内存较大的情况下；

CMS的各阶段：
   1、	Initial Mark（初始标记，需STW）：标记所有的根对象，包括根对象直接引用的对象，以及被年轻代存活对象引用的对象。（通常这个时候，是由于年轻代经过MinorGC之后，有对象需要晋升到老年代，但老年代空间不足，老年代需要进行一次GC。所以这时年轻代的对象大部分都是有用的对象）
   2、	Concurrent Mark（并发标记）：根据阶段1标记的根对象进行并发标记，与业务线程同时进行；
   3、	Concurrent Preclean（并发预清理）：对阶段2发生引用关系变化的对象，进行卡片标记。此阶段完成后，会更新对象的引用关系，用以标记的卡片也会被清空；
   4、	Concurrent Abortable Preclean（可取消的并发预清理）：本阶段尝试在STW的Final Remark阶段之前，尽可能地所做一些工作；
   5、	Final Remark（最终标记，需STW）：完成老年代中所有存活对象的最终标记。之所以要有这么一个阶段，是因为之前的标记都是并发执行的，有可能GC线程跟不上业务线程的修改速度，所以需要STW最终标记一下；
   6、	Concurrent Sweep（并发清除）：删除不再使用的对象，并回收它们的空间；
   7、	Concurrent Reset（并发重置）：重置CMS算法相关的内部数据，为下一次GC做准备；



四、G1：
   1、将堆划分为多个Region，通常是2048个，每个小块可被划分为Eden区、Survivor区或Old区，并且不恒定；
   2、逻辑上：年轻代为所有被划分为Eden区和Survivor区的小块的集合，老年代同理；
   3、每次GC暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的区块；
   4、G1构建回收集的原则：垃圾最多的小块会被优先收集；
   5、年轻代模式暂停转移：当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果没有存活区，则任意选择一部分空闲的内存块作为存活区；
   6、G1的并发标记有些是完全并发的，有些则会暂停应用程序，如下两种情况是并发执行的：
      一、如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾；
      二、在STW转移暂停期间，同事包含垃圾和存活对象的老年代小堆块；
总结：相对比CMS，G1的优点：暂停时间的可预测性，终结堆内存的碎片化；

G1的各阶段：
   1、	Initial Mark（初始标记）：标记所有从GC根对象直接可达的对象；
   2、	Root Region Scan（Root区扫描）：标记所有从“根区域”可达的存活对象；
   3、	Concurrent Mark（并发标记）：并发对对象图执行引用更新；
   4、	Remark（再次标记，STW）：类似CMS，STW来完成最后的标记；
   5、	Clean up（清理，需要短暂的STW）：将所有不包含存活对象的小堆块在此阶段进行回收；





